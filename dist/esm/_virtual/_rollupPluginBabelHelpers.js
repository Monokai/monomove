function e(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function t(e,t){return c(e,r(e,t,"get"))}function a(e,t,a){return o(e,r(e,t,"set"),a),a}function r(e,t,a){if(!t.has(e))throw new TypeError("attempted to "+a+" private field on non-instance");return t.get(e)}function i(e,t,a){return l(e,t),f(a,"get"),c(e,a)}function n(e,t,a,r){return l(e,t),f(a,"set"),o(e,a,r),r}function s(e,t,a){return l(e,t),a}function c(e,t){return t.get?t.get.call(e):t.value}function o(e,t,a){if(t.set)t.set.call(e,a);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=a}}function l(e,t){if(e!==t)throw new TypeError("Private static access of wrong provenance")}function f(e,t){if(void 0===e)throw new TypeError("attempted to "+t+" private static field before its declaration")}function p(e,t,a){if(!t.has(e))throw new TypeError("attempted to get private field on non-instance");return a}function u(e,t){if(t.has(e))throw new TypeError("Cannot initialize the same private elements twice on an object")}function d(e,t,a){u(e,t),t.set(e,a)}function v(e,t){u(e,t),t.add(e)}export{u as checkPrivateRedeclaration,c as classApplyDescriptorGet,o as classApplyDescriptorSet,l as classCheckPrivateStaticAccess,f as classCheckPrivateStaticFieldDescriptor,r as classExtractFieldDescriptor,t as classPrivateFieldGet,d as classPrivateFieldInitSpec,a as classPrivateFieldSet,p as classPrivateMethodGet,v as classPrivateMethodInitSpec,i as classStaticPrivateFieldSpecGet,n as classStaticPrivateFieldSpecSet,s as classStaticPrivateMethodGet,e as defineProperty};
