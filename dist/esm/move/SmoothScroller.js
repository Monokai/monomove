import t from"../math/clamp.js";import i from"./RenderLoop.js";import s from"./Tween.js";let e=!1;try{const t=Object.defineProperty({},"passive",{get:()=>(e=!0,!0)});window.addEventListener("a",null,t),window.removeEventListener("a",null,t)}catch(t){}class o{isDown=!1;isLocked=!1;scroll=0;scrollHeight=0;#t=.01;#i=0;#s=0;#e=0;#o=[];#n=null;#l=null;#r=null;#h=!1;#c=0;#a=0;#d=0;#u=null;#g=null;#v=null;#w=null;#m=!0;#f=!1;#p=!1;#b=(new s).easing("0.35,0.15,0,1").onUpdate((t=>{window.scrollTo(0,t.y),this.#h=!0,this.scroll=t.y,this.#i=t.y,this.isDown=this.#i>=this.#s,this.#s=this.#i})).onStart((()=>{this.#p=!0})).onComplete((()=>{this.#p=!1}));#S=!!e&&{passive:!0};#x=null;#T=null;#L=null;#O=null;#C=null;#A=null;#I=null;#F=0;#D=0;#k=0;constructor(){let{container:s=window.document.body,content:e=window.document.body,easing:o=(t=>Math.min(1,1.001-2**(-10*t))),scrollFactor:n=null,scrollDuration:l=0,listener:r=window,debug:h=!1,onResize:c}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(this.#T=l,this.#L=s,this.#O=e,this.#C=r,this.#A=h,this.#k=o,this.#I=c,n)throw new Error("scrollFactor is deprecated, please use scrollDuration");this.#u=()=>{this.isLocked||(this.#f=!0)},this.#g=()=>{this.isLocked||(this.#h=!0,this.#i=t(this.getScrollPosition(),0,Math.round(this.scrollHeight-this.#e)),this.#D=this.scroll,this.#F=0)},this.#w=t=>{t.stopPropagation(),this.isLocked||(this.#f=!1)},this.#v=()=>{this.isLocked||(this.#b&&this.#b.stop(),this.#f=!1,this.#p=!1)},this.#C&&(this.#A,this.#C.addEventListener("touchstart",this.#u,this.#S),this.#C.addEventListener("scroll",this.#g,this.#S),this.#C.addEventListener("mousedown",this.#w,this.#S),this.#C.addEventListener("wheel",this.#v,this.#S)),this.#A&&(this.#l=window.document.createElement("canvas"),this.#L.appendChild(this.#l)),i.add(this,this.#y),i.play(),this.resize()}#y(i){if(this.isLocked)return!0;if(this.scrollWidth=this.#O?.scrollWidth??0,this.scrollHeight=this.#O?.scrollHeight??0,this.scrollWidth!==this.#a||this.scrollHeight!==this.#d)return this.resize(),this.scroll=this.#D=this.#i,this.#E(this.scroll),this.#a=this.scrollWidth,this.#d=this.scrollHeight,!0;if(!this.#h)return!0;Math.abs(this.#i-this.scroll)<this.#t&&(this.#A,this.#f&&(this.#A,this.triggerAnimations(!0)),this.#h=!1),this.#F+=i/1e3;const s=t(this.#F/(this.#f?this.#x:this.#T),0,1),e=this.#k(s);if(this.scroll=this.#D+(this.#i-this.#D)*e,this.#m){this.#m=!1,this.scroll=this.#D=this.#i,this.#A;const t=this.isDown;this.isDown=!0,this.triggerAnimations(!0),this.isDown=!1,this.triggerAnimations(!0),this.isDown=t}return null===this.#n&&(this.#n=this.#o),this.#E(this.scroll),!0}draw(){this.#E()}drawAll(){const t=this.#n;this.#n=this.#o,this.#E(),this.#n=t}getScrollPosition(){return void 0!==this.#C.scrollY?this.#C.scrollY:void 0!==this.#C.pageYOffset?this.#C.pageYOffset:void 0!==this.#C.scrollTop?this.#C.scrollTop:0}resize(){this.#L&&this.#O&&(this.scroll=this.#D=this.#s=this.#i,this.scrollHeight=this.#O.scrollHeight,this.#e=window.innerHeight,this.#o.forEach((t=>{this.#H(t)})),this.#l&&(this.#l.width=window.innerWidth*window.devicePixelRatio,this.#l.height=window.innerHeight*window.devicePixelRatio,this.#l.style.position="fixed",this.#l.style.left=0,this.#l.style.top=0,this.#l.style.width=`${window.innerWidth}px`,this.#l.style.height=`${window.innerHeight}px`,this.#l.style.pointerEvents="none",this.#l.style.zIndex=9999999,this.#r=this.#l.getContext("2d")),this.#I&&this.#I(),this.#B())}triggerAnimations(){let i=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const s=window.devicePixelRatio;this.#r&&(this.#r.clearRect(0,0,this.#l.width,this.#l.height),this.#r.strokeStyle="#f00",this.#r.lineWidth=2*s,this.#r.beginPath()),(i?this.#o:this.#n).forEach((i=>{const e=i.box;if(!e||!e.width||!e.height)return;const o=i.animationObject;o.scroll=this.scroll;const n=i.directionOffset||0,l=i.offset||0,r=e.top+e.height-o.scroll+n*(this.isDown?-1:1)*this.#e+l*this.#e,h=r/(this.#e+e.height),c=(r-this.#e)/e.height;o.rawFactor=(1-h-.5)*i.speed+.5,o.rawBoxFactor=(1-c-.5)*i.speed+.5,o.factor=t(o.rawFactor,0,1),o.isInView=o.rawFactor>=0&&o.rawFactor<=1,o.boxFactor=t(o.rawBoxFactor,0,1),o.boxIsInView=o.rawBoxFactor>=0&&o.rawBoxFactor<=1,o.box=e,o.item=i.item,o.fixedTop&&(o.box.top=o.fixedTop),o.isInView!==o.previousIsInView&&(o.isInView?(o.isScrolledIn=!0,void 0===o.isScrolledInOnce&&(o.isScrolledInOnce=!0)):void 0!==o.previousIsInView&&(o.isScrolledOut=!0,void 0===o.isScrolledOutOnce&&(o.isScrolledOutOnce=!0))),i.animation&&i.previousFactor!==o.factor&&(i.animation(o),i.previousFactor=o.factor),o.isScrolledIn=!1,o.isScrolledOut=!1,!0===o.isScrolledInOnce&&(o.isScrolledInOnce=!1),!0===o.isScrolledOutOnce&&(o.isScrolledOutOnce=!1),o.previousIsInView=o.isInView,this.#r&&o.box.top+o.box.height-o.scroll>=0&&o.box.top-o.scroll<=this.#e&&this.#r.rect(o.box.left*s,o.box.top*s-o.scroll*s,o.box.width*s,o.box.height*s)})),this.#r&&this.#r.stroke()}#E(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;this.isDown=t>=this.#s,this.#n&&(this.triggerAnimations(),this.#s=t)}add(t,i){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const e=t&&t instanceof Array?t:[t];void 0===s.observeIn&&(s.observeIn=null),e.forEach((t=>{const e={centerOffset:0,originalTop:0,isVisible:!0};let o=null;window.IntersectionObserver&&void 0!==s.observeIn?(o=new window.IntersectionObserver((t=>{t.forEach((t=>{e.isVisible=t.isIntersecting,this.#B()}))}),{root:s.observeIn,rootMargin:`${s.directionOffset?100*s.directionOffset:s.speed?1/s.speed*100:0}% 0% ${s.directionOffset?100*s.directionOffset:s.offset?100*s.offset:s.speed?1/s.speed*100:0}% 0%`,threshold:0}),o.observe(t)):this.#n=null;const n={animation:i,directionOffset:s.directionOffset||0,offset:s.offset||0,speed:void 0===s.speed?1:s.speed,animationObject:e,item:t,observer:o};this.#H(n),this.#o.push(n)}))}#B(){this.#n=this.#o.filter((t=>t.animationObject.isVisible)),this.#A}remove(t){const i=t&&t instanceof Array?t:[t];this.#o=this.#o.filter((t=>i.indexOf(t.item)<0))}static getBox(t){let i=t,s=0,e=0;do{if(void 0===i.offsetLeft){const t=i.getBoundingClientRect(),o=window.document.documentElement;s+=t.left+window.pageXOffset-o.clientLeft,e+=t.top+window.pageYOffset-o.clientTop}else s+=i.offsetLeft,e+=i.offsetTop;i=i.offsetParent}while(i);if(void 0===t.offsetWidth){const i=t.getBoundingClientRect();return{left:s,top:e,width:i.width,height:i.height}}return{left:s,top:e,width:t.offsetWidth,height:t.offsetHeight}}#H(t){t.box=o.getBox(t.item),t.animationObject.centerOffset=.5*(this.#e-t.box.height),t.animationObject.originalTop=t.box.top,t.animationObject.scroll=t.animationObject.targetScroll=this.#i}scrollTo(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return this.#b.from({y:this.scroll}).to({y:i},s??t(25e-5*Math.abs(i-this.scroll),.25,2.5)).start()}scrollToElement(t){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;const e=o.getBox(t);return this.scrollTo(e.top+i,s)}reset(){this.#o.length=0,this.#e=0}stop(){this.#h=!1}lock(){this.isLocked=!0}unlock(){this.isLocked=!1,window.scrollTo(0,this.scroll)}setContent(t){this.#O=t,this.resize()}unsetContent(){this.#O=null}setScrollDuration(t){this.#T=t}setTouchScrollDuration(t){this.#x=t}destroy(){this.#A&&this.#l.remove(),this.#C&&(this.#A,this.#C.removeEventListener("touchstart",this.#u,this.#S),this.#C.removeEventListener("wheel",this.#v,this.#S),this.#C.removeEventListener("mousedown",this.#w,this.#S),this.#C.removeEventListener("scroll",this.#g,this.#S)),this.reset(),this.stop()}}export{o as default};
