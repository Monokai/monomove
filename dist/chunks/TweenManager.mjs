const t=(t,i,s)=>(((1-3*s+3*i)*t+(3*s-6*i))*t+3*i)*t,i=(t,i,s)=>3*(1-3*s+3*i)*t**2+2*(3*s-6*i)*t+3*i;class s{iterations=4;precision=1e-5;newtonRaphsonMinSlope=.001;subdivisionPrecision=1e-7;subdivisionIterations=10;t=11;i=0;o=[0];h;l;u;p;S;constructor(t,i=0,s=0,e=0){if(this.cacheSize=this.t,'string'==typeof t){const i=t.split(',');this.h=+i[0],this.l=+i[1],this.u=+i[2],this.p=+i[3]}else this.h=t,this.l=i,this.u=s,this.p=e;this.S=!1}_(i,s,e,n,o){let h,r,c=0;do{r=s+(e-s)/2,h=t(r,n,o)-i,h>0?e=r:s=r}while(Math.abs(h)>this.subdivisionPrecision&&++c<this.subdivisionIterations);return r}v(s,e,n,o){let h=e;for(let e=0;e<this.iterations;++e){const e=i(h,n,o);if(0===e)return h;const r=t(h,n,o)-s;if(Math.abs(r)<this.precision)return h;h-=r/e}return h}M(){this.o=Array(this.t);for(let i=0;i<this.t;++i)this.o[i]=t(i*this.i,this.h,this.u);this.S=!0}m(t){let s=0,e=1;const n=this.t-1;for(;e!==n&&this.o[e]<=t;++e)s+=this.i;--e;const o=s+(t-this.o[e])/(this.o[e+1]-this.o[e])*this.i,h=i(o,this.h,this.u);return h>=this.newtonRaphsonMinSlope?this.v(t,o,this.h,this.u):0===h?o:this._(t,s,s+this.i,this.h,this.u)}get(i){return this.S||this.M(),0===i?0:1===i?1:t(this.m(i),this.l,this.p)}set cacheSize(t){this.t=t,this.i=1/(this.t-1),this.o=Array(this.t),this.S=!1}get cacheSize(){return this.t}}const e=[],n=new Map,o=new Map;let h=!1;const r={bezierIterations:null,bezierCacheSize:null,bezierPrecision:null,bezierNewtonRaphsonMinSlope:null,bezierSubdivisionPrecision:null,bezierSubdivisionIterations:null,getAll:()=>{const t=[],i=e.length;for(let s=0;s<i;s++){const i=e[s];null!==i&&t.push(i)}return t},removeAll:()=>{const t=e.length;for(let i=0;i<t;i++)e[i]?.stop();e.length=0,n.clear()},add:t=>{e.push(t)},remove:t=>{const i=e.indexOf(t);-1!==i&&(h?e[i]=null:e.splice(i,1))},register:(t,i)=>{o.set(t,i)},registerAll:t=>{for(const i in t){const s=t[i];4===s.length&&o.set(i,s)}},onTick:t=>{const i=e.length;if(0===i)return!1;h=!0;let s=0;for(let n=0;n<i;n++){const i=e[n];null!==i&&i.update(t)&&(n!==s&&(e[s]=i),s++)}h=!1;const n=e.length;if(n>i)for(let t=i;t<n;t++)e[s++]=e[t];return e.length=s,s>0},getEasingFromCache:t=>{if(!n.has(t))if(o.has(t)){const[i,e,h,r]=o.get(t);n.set(t,new s(i,e,h,r))}else n.set(t,new s(t));return n.get(t)},setEasingOptions:(t,i={})=>{const s={iterations:r.bezierIterations,cacheSize:r.bezierCacheSize,precision:r.bezierPrecision,newtonRaphsonMinSlope:r.bezierNewtonRaphsonMinSlope,subdivisionPrecision:r.bezierSubdivisionPrecision,subdivisionIterations:r.bezierSubdivisionIterations,...i},e=Object.keys(s);for(const i of e){const e=s[i];null!==e&&(t[i]=e)}}};export{s as C,r as T};
