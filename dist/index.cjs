"use strict";var t;Object.defineProperty(exports,"__esModule",{value:!0});class i{#t;#i;#e=0;#s=[0];#o;#n;#l;#a;#r;static#h(t,i,e){return(((1-3*e+3*i)*t+(3*e-6*i))*t+3*i)*t}static#c(t,i,e){return 3*(1-3*e+3*i)*t**2+2*(3*e-6*i)*t+3*i}constructor(t,i=0,e=0,s=0){if(this.#t=16,this.#i=11,this.setCacheSize(this.#i),"string"==typeof t){const i=t.split(",");this.#o=Number(i[0]),this.#n=Number(i[1]),this.#l=Number(i[2]),this.#a=Number(i[3])}else this.#o=t,this.#n=i,this.#l=e,this.#a=s;this.#r=!1}#u(i,e,s,o){let n=e;for(let e=0;e<this.#t;++e){const e=t.#c(n,s,o);if(0===e)return n;n-=(t.#h(n,s,o)-i)/e}return n}#_(){this.#s=new Array(this.#i);for(let i=0;i<this.#i;++i)this.#s[i]=t.#h(i*this.#e,this.#o,this.#l);this.#r=!0}#d(t){const i=this.#i-1;let e=0,s=1;for(;s!==i&&this.#s[s]<=t;++s)e+=this.#e;--s;const o=e+(t-this.#s[s])/(this.#s[s+1]-this.#s[s])*this.#e;return this.#u(t,o,this.#o,this.#l)}get(i){return this.#r||this.#_(),0===i?0:1===i?1:t.#h(this.#d(i),this.#n,this.#a)}setIterations(t){this.#t=t}setCacheSize(t){this.#i=t,this.#e=1/(this.#i-1),this.#s=new Array(this.#i),this.#r=!1}}t=i;class e{static _tweens=[];static _time=0;static _easingCache=new Map;static _isUpdating=!1;static bezierIterations=null;static bezierCacheSize=null;static getAll(){const t=[],i=this._tweens.length;for(let e=0;e<i;e++){const i=this._tweens[e];null!==i&&t.push(i)}return t}static removeAll(){const t=this._tweens.length;for(let i=0;i<t;i++)this._tweens[i]?.stop();this._tweens.length=0,this._easingCache.clear()}static add(t){this._tweens.push(t)}static remove(t){const i=this._tweens.indexOf(t);-1!==i&&(this._isUpdating?this._tweens[i]=null:this._tweens.splice(i,1))}static onlyHasDelayedTweens(t){const i=this._tweens,e=i.length;for(let s=0;s<e;s++){const e=i[s];if(null!==e&&(null===e.startTime||t>=e.startTime))return!1}return e>0}static onTick(t){const i=this._tweens,e=i.length;if(0===e)return!1;this._time=t,this._isUpdating=!0;let s=0;for(let o=0;o<e;o++){const e=i[o];null!==e&&e.update(t)&&(o!==s&&(i[s]=e),s++)}this._isUpdating=!1;const o=i.length;if(o>e)for(let t=e;t<o;t++)i[s++]=i[t];return i.length=s,!0}static setBezierIterations(t){this.bezierIterations=t}static setBezierCacheSize(t){this.bezierCacheSize=t}static getEasingFromCache(t){return this._easingCache.has(t)||this._easingCache.set(t,new i(t)),this._easingCache.get(t)}}class s{static _subscribers=[];static _cleanups=[];static _isUpdating=!1;static _activeCount=0;static _ms=0;static _time=0;static _previousTime=0;static _pauseTime=0;static _pauseTimeStart=0;static _isAnimating=!1;static _requestAnimation=!1;static _requestID=0;static _onlyHasDelayedTweens=!1;static _isFirstTime=!0;static _loopHandler=s._animate.bind(s);static _animate(){const t=window.performance.now();this._time=t-this._pauseTime,this._ms=this._previousTime?this._time-this._previousTime:0;const i=e.onTick(this._time);this._isUpdating=!0;let s=0;const o=this._subscribers.length,n=this._subscribers;for(let t=0;t<o;t++){const i=n[t];null!==i&&!0===i(this._ms)&&s++}if(!this._onlyHasDelayedTweens){const t=this._cleanups;for(let i=0;i<o;i++){const e=t[i];null!==e&&null!==n[i]&&e()}}this._isUpdating=!1,this._activeCount<n.length&&this._compact(),this._onlyHasDelayedTweens=0===s&&e.onlyHasDelayedTweens(this._time),this._previousTime=this._time,this._isAnimating&&(s>0||i)?this._requestID=window.requestAnimationFrame(this._loopHandler):this._requestAnimation=!1}static _compact(){let t=0;const i=this._subscribers.length,e=this._subscribers,s=this._cleanups;for(let o=0;o<i;o++){const i=e[o];null!==i&&(o!==t&&(e[t]=i,s[t]=s[o]),t++)}e.length=t,s.length=t,this._activeCount=t}static stop(t){this._isAnimating=!1,window.cancelAnimationFrame(this._requestID),t&&t()}static add(t,i){this._subscribers.push(t),this._cleanups.push(i||null),this._activeCount++,this.trigger()}static reset(){this._subscribers.length=0,this._cleanups.length=0,this._activeCount=0,e.removeAll()}static remove(t){const i=this._subscribers.indexOf(t);-1!==i&&(this._isUpdating?(this._subscribers[i]=null,this._cleanups[i]=null,this._activeCount--):(this._subscribers.splice(i,1),this._cleanups.splice(i,1),this._activeCount--)),this.trigger()}static trigger(){this._onlyHasDelayedTweens=!1,this._requestAnimation||(this._requestAnimation=!0,this._requestID=window.requestAnimationFrame(this._loopHandler))}static getTime(){return this._time=window.performance.now()-this._pauseTime,this._time}static pause(){this._isAnimating&&(this._pauseTimeStart=window.performance.now(),this._requestAnimation=!1,this.stop())}static play(){this._isAnimating||(this._isFirstTime||(this._pauseTime+=window.performance.now()-this._pauseTimeStart),this._isFirstTime=!1,this.triggerAnimation())}static triggerAnimation(){this._isAnimating=!0,this.trigger()}static isPlaying(){return this._isAnimating}}class o{durationMS;isPlaying;delayTime;startTime;easingFunction;object;value;onTimelineInCallback=null;onTimelineOutCallback=null;onTimelineVisibleCallback=null;onTimelineInvisibleCallback=null;timelineIn=!1;previousTimelineIn=!1;timelineVisible=!1;previousTimelineVisible=!1;_onUpdateCallback;_onLoopCallback;_onCompleteCallback;_onStartCallback;_valuesEnd;_valuesStart;_propKeys;_propStartValues;_propChangeValues;_loopNum;_loopCount;_onStartCallbackFired;_previousTime;_elapsed;_previousUpdateValue;_inverseDuration;_targetIsFunction;constructor(t,i=1){if(this.durationMS=1e3*i,this._inverseDuration=this.durationMS>0?1/this.durationMS:0,this.easingFunction=t=>t,this.value=0,this.delayTime=0,this.isPlaying=!1,this.startTime=null,this._loopNum=0,this._loopCount=0,this._onLoopCallback=null,this._onCompleteCallback=null,this._onStartCallback=null,this._onStartCallbackFired=!1,this._previousTime=null,this._elapsed=0,this._previousUpdateValue=null,this._valuesStart={},this._propKeys=[],this._propStartValues=[],this._propChangeValues=[],"function"==typeof t)this._targetIsFunction=!0,this.object=null,this._onUpdateCallback=t,this._valuesStart.value=0,this._valuesEnd={value:1};else{this._targetIsFunction=!1,this.object=t,this._onUpdateCallback=null,this._valuesEnd={};const i=this.object,e=Object.keys(i);for(let t=0;t<e.length;t++){const s=e[t],o=i[s];"number"==typeof o&&(this._valuesStart[s]=o)}}}from(t){if(this._targetIsFunction){const i=t,e=Object.keys(i);for(const t of e){const e=i[t];"number"==typeof e&&(this._valuesStart[t]=e)}}else for(const i in t){const e=t[i];"number"==typeof e&&this.object&&(this.object[i]=e,this._valuesStart[i]=e)}return this._onUpdateCallback&&this.updateAllValues(0),this}to(t,i){return void 0!==i&&(this.durationMS=1e3*i,this._inverseDuration=this.durationMS>0?1/this.durationMS:0),this._valuesEnd=t,this}duration(t){return this.durationMS=1e3*t,this._inverseDuration=this.durationMS>0?1/this.durationMS:0,this}rewind(){if(!this._targetIsFunction&&this.object){const t=this.object;for(const i in this._valuesStart)t[i]=this._valuesStart[i]}return this.value=this.easingFunction(0),this}restart(){return this.rewind().start()}loop(t=1/0){return this._loopNum=t,this._loopCount=t,this}setLoopCallback(t){return this._onLoopCallback=t,this}startTween(t=s.getTime()){const i=this.isPlaying;if(this._elapsed=0,this._onStartCallbackFired=!1,this.isPlaying=!0,this.startTime=t+this.delayTime,this._propKeys.length=0,this._propStartValues.length=0,this._propChangeValues.length=0,!this._targetIsFunction&&this.object){let t=!1;for(const i in this._valuesEnd){t=!0;break}if(!t){const t=this.object;for(const i in t)if(i in this._valuesStart){const e=t[i];"number"==typeof e&&(this._valuesEnd[i]=e)}}}for(const t in this._valuesEnd){const i=this._valuesEnd[t];let e=this._valuesStart[t];if(!this._targetIsFunction&&void 0===e&&this.object){const i=this.object[t];"number"==typeof i&&(e=i,this._valuesStart[t]=e)}this._targetIsFunction&&void 0===e&&(e=0),"number"==typeof e&&"number"==typeof i&&(this._propKeys.push(t),this._propStartValues.push(e),this._propChangeValues.push(i-e))}return 0===this.durationMS&&0===this._loopNum&&0===this.delayTime?(this.update(t),this.isPlaying=!1):i||(e.add(this),s.triggerAnimation()),this}start(t){const i=this._onCompleteCallback;return new Promise((e=>{this._onCompleteCallback=(t,s)=>{i&&i(t,s),this._onCompleteCallback=i,e(this)},this.startTween(t)}))}stop(){return this.isPlaying?(this.isPlaying=!1,e.remove(this),this):this}delay(t){return this.delayTime=1e3*t,this}easing(t=(t=>t),{iterations:i=e.bezierIterations??void 0,cacheSize:s=e.bezierCacheSize??void 0}={}){if(!t)return this;if("string"==typeof t){const o=e.getEasingFromCache(t);i&&o.setIterations&&o.setIterations(i),s&&o.setCacheSize&&o.setCacheSize(s),this.easingFunction=o.get.bind(o)}else if("object"==typeof t&&null!==t&&"get"in t){const e=t;i&&e.setIterations&&e.setIterations(i),s&&e.setCacheSize&&e.setCacheSize(s),this.easingFunction=e.get.bind(e)}else this.easingFunction=t;return this}onStart(t){return this._onStartCallback=t,this}onUpdate(t){return this._onUpdateCallback=t,this}onComplete(t=null){return this._onCompleteCallback=t,this}onTimelineIn(t){return this.onTimelineInCallback=t,this}onTimelineOut(t){return this.onTimelineOutCallback=t,this}onTimelineVisible(t){return this.onTimelineVisibleCallback=t,this}onTimelineInvisible(t){return this.onTimelineInvisibleCallback=t,this}setPosition(t){const i=t<0?0:t>1?1:t;this.value=this.easingFunction(i),this.updateAllValues()}updateAllValues(t=0){if(this.value!==this._previousUpdateValue){if(this._targetIsFunction){if(this._propStartValues.length>0){const i=this._propStartValues[0]+this._propChangeValues[0]*this.value;this._onUpdateCallback&&this._onUpdateCallback(i,this.value,t)}}else{const i=this._propKeys.length,e=this._propKeys,s=this._propStartValues,o=this._propChangeValues,n=this.value,l=this.object;for(let t=0;t<i;t++)l[e[t]]=s[t]+o[t]*n;this._onUpdateCallback&&this._onUpdateCallback(this.object,n,t)}this._previousUpdateValue=this.value}}invalidate(){return this._previousUpdateValue=null,this}update(t){if(null===this.startTime)return!0;if(t<this.startTime)return!0;!1===this._onStartCallbackFired&&(null!==this._onStartCallback&&this.object&&this._onStartCallback(this.object),this._onStartCallbackFired=!0,s.trigger()),this._elapsed=t-this.startTime;const i=0===this.durationMS?1:this._elapsed*this._inverseDuration,e=i>1?1:i;this.value=this.easingFunction(e),null===this._previousTime&&(this._previousTime=t);const o=t-this._previousTime;if(this._previousTime=t,this.updateAllValues(o),1===e){const e=this.startTime;this._loopCount>0?(this._onLoopCallback&&this.object&&this._onLoopCallback(this.object,this._loopNum-this._loopCount),this._loopCount--,this.restart()):this._onCompleteCallback&&this.isPlaying&&this.object&&this._onCompleteCallback(this.object,t-this.startTime);const s=e!==this.startTime;return this.isPlaying=s||this.isPlaying&&i<1,this.isPlaying}return!0}}class n{previousPosition;startTime=null;delayTime=0;durationMS=0;value=0;easingFunction=t=>t;_driverTween=null;_tweens=[];_loopNum=0;totalTime=0;constructor({delay:t=0}={}){this.previousPosition=0,this.delayTime=1e3*t}static setTweenIn(t,i){t.timelineIn=i,t.timelineIn!==t.previousTimelineIn&&(i&&t.onTimelineInCallback&&t.object?t.onTimelineInCallback(t.object):!i&&t.onTimelineOutCallback&&t.object&&t.onTimelineOutCallback(t.object),t.previousTimelineIn=t.timelineIn)}static setTweenVisibility(t,i){t.timelineVisible=i,t.timelineVisible!==t.previousTimelineVisible&&(i&&t.onTimelineVisibleCallback&&t.object?t.onTimelineVisibleCallback(t.object):!i&&t.onTimelineInvisibleCallback&&t.object&&t.onTimelineInvisibleCallback(t.object),t.previousTimelineVisible=t.timelineVisible)}delay(t){return this.delayTime=1e3*t,this}loop(t=1/0){return this._loopNum=t,this}stop(){return this._driverTween?.stop(),this}destroy(){this.stop();for(let t=0;t<this._tweens.length;t++)this._tweens[t].stop();this._tweens.length=0,this.totalTime=0}start(){const t=new o((t=>{this.setPosition(t)}),this.totalTime/1e3);return this._driverTween=t,0!==this._loopNum&&t.loop(this._loopNum),t.delay(this.delayTime/1e3),t.start().then((()=>this))}updateAllValues(){}invalidate(){}}function l(t,i,e=Number.MAX_VALUE){return t<i?i:t>e?e:t}class a extends n{_startTimes=[];_durations=[];_cursor=0;constructor(t){super(t)}add(t,i=0){const e=void 0!==t.totalTime?t.totalTime:t.durationMS,s=1e3*i,o=this._cursor+s;return this._register(t,o,e),this}at(t,i){const e=void 0!==i.totalTime?i.totalTime:i.durationMS,s=1e3*t;return this._register(i,s,e),this}_register(t,i,e){t.delayTime=i,this._tweens.push(t),this._startTimes.push(i),this._durations.push(e);const s=i+e;s>this._cursor&&(this._cursor=s),s>this.totalTime&&(this.totalTime=s)}setPosition(t){const i=l(t,0,1)*this.totalTime,e=this._tweens.length,s=this._startTimes,a=this._durations,r=this._tweens;for(let t=0;t<e;t++){const e=r[t],l=s[t],h=a[t],c=l+h;if(i<l)e.setPosition(0),e instanceof o&&(n.setTweenVisibility(e,!1),n.setTweenIn(e,!1),e.invalidate(),e.updateAllValues());else if(i>=c)e.setPosition(1),e instanceof o&&(n.setTweenVisibility(e,!0),n.setTweenIn(e,!1),e.invalidate(),e.updateAllValues());else{const t=0===h?1:(i-l)/h;e.setPosition(t),e instanceof o&&(n.setTweenVisibility(e,!0),n.setTweenIn(e,!0),e.invalidate(),e.updateAllValues())}}this.previousPosition=t}update(t){return this.setPosition(this.previousPosition||0),!0}}let r=!1;try{const t=Object.defineProperty({},"passive",{get:()=>(r=!0,!0)});window.addEventListener("test",(()=>{}),t),window.removeEventListener("test",(()=>{}),t)}catch(t){}const h=!!r&&{passive:!0};class c{isDown=!1;isLocked=!1;scroll=0;scrollWidth=0;scrollHeight=0;_pixelRatio=1;_scrollThreshold=.01;_targetScroll=0;_previousScroll=0;_viewportHeight=0;_animations=[];_activeAnimations=new Set;_smoothAnimations=new Set;_debugCanvas=null;_debugContext=null;_isAnimating=!1;_previousScrollWidth=0;_previousScrollHeight=0;_isFirstScrollInstant=!0;_isTouch=!1;_scrollTween=new o({y:0}).easing("0.35,0.15,0,1").onUpdate((t=>{window.scrollTo(0,t.y),this._isAnimating=!0,this.scroll=t.y,this._targetScroll=t.y,this.isDown=this._targetScroll>=this._previousScroll,this._previousScroll=this._targetScroll}));_touchScrollDuration=0;_scrollDuration=0;_container;_content;_listener;_debug=!1;_onResizeFunk=null;_totalTickTime=0;_scrollFrom=0;_easing;_getScrollFn;_tickHandler=this._onTick.bind(this);_touchStartHandler=()=>{this.isLocked||(this._isTouch=!0)};_mouseDownHandler=t=>{t.stopPropagation(),this.isLocked||(this._isTouch=!1)};_wheelHandler=()=>{this.isLocked||(this._scrollTween.stop(),this._isTouch=!1)};_scrollHandler=()=>{if(this.isLocked)return;this._isAnimating=!0;const t=Math.max(0,this.scrollHeight-this._viewportHeight),i=this._getScrollFn();this._targetScroll=i<0?0:i>t?t:i,this._scrollFrom=this.scroll,this._totalTickTime=0};constructor({container:t=window.document.body,content:i=window.document.body,easing:e=(t=>Math.min(1,1.001-2**(-10*t))),scrollFactor:o=null,scrollDuration:n=0,listener:l=window,debug:a=!1,onResize:r}={}){if(this._scrollDuration=n||0,this._container=t,this._content=i,this._listener=l,this._debug=a||!1,this._easing=e,this._onResizeFunk=r||null,"scrollY"in this._listener)this._getScrollFn=()=>this._listener.scrollY;else if("pageYOffset"in this._listener)this._getScrollFn=()=>this._listener.pageYOffset;else{const t=this._listener;this._getScrollFn=()=>t.scrollTop}this._setupListeners(),this._setupDebug(),s.add(this._tickHandler),s.play(),this.resize()}_setupListeners(){if(!this._listener)return;const t=h,i=this._listener;i.addEventListener("touchstart",this._touchStartHandler,t),i.addEventListener("scroll",this._scrollHandler,t),i.addEventListener("mousedown",this._mouseDownHandler,t),i.addEventListener("wheel",this._wheelHandler,t)}_setupDebug(){this._debug&&this._container&&(this._debugCanvas=document.createElement("canvas"),this._container.appendChild(this._debugCanvas))}_onTick(t){if(this.isLocked)return!0;const i=this._content.scrollWidth,e=this._content.scrollHeight;if(i!==this.scrollWidth||e!==this.scrollHeight)return this.scrollWidth=i,this.scrollHeight=e,this._previousScrollWidth=i,this._previousScrollHeight=e,this.resize(),this.scroll=this._scrollFrom=this._targetScroll,this._updateAll(this.scroll),!0;if(this._smoothAnimations.size>0)for(const i of this._smoothAnimations)Math.abs(i.animationObject.smoothScrollValue-this.scroll)>this._scrollThreshold&&this._triggerAnimation(i,void 0,t);if(!this._isAnimating)return!0;const s=this._targetScroll-this.scroll;if(Math.abs(s)<this._scrollThreshold)return Math.abs(s)>0&&(this.scroll=this._targetScroll,this._updateAll(this.scroll)),this._isTouch&&this.triggerAnimations(!0),this._isAnimating=!1,!0;this._totalTickTime+=t/1e3;const o=this._isTouch?this._touchScrollDuration:this._scrollDuration,n=0===o?1:l(this._totalTickTime/o,0,1),a=this._easing(n);if(this.scroll=this._scrollFrom+(this._targetScroll-this._scrollFrom)*a,this._isFirstScrollInstant){this._isFirstScrollInstant=!1,this.scroll=this._scrollFrom=this._targetScroll;const t=this.isDown;this.isDown=!0,this.triggerAnimations(!0),this.isDown=!1,this.triggerAnimations(!0),this.isDown=t}return this._updateAll(this.scroll),!0}_updateAll(t){if(this.isDown=t>=this._previousScroll,this._previousScroll=t,this._activeAnimations.size>0)for(const t of this._activeAnimations)this._triggerAnimation(t);this._debugContext&&this._drawDebug()}draw(){this._updateAll(this.scroll)}drawAll(){for(const t of this._animations)this._triggerAnimation(t)}getScrollPosition(){return this._getScrollFn()}resize(){if(!this._container||!this._content)return;this.scroll=this._scrollFrom=this._previousScroll=this._targetScroll,this.scrollHeight=this._content.scrollHeight,this._viewportHeight=window.innerHeight,this._pixelRatio=window.devicePixelRatio;const t=window.scrollY||window.pageYOffset;for(let i=0;i<this._animations.length;i++)this._initBox(this._animations[i],t);if(this._debugCanvas){const t=window.innerWidth,i=window.innerHeight,e=this._pixelRatio;this._debugCanvas.width=t*e,this._debugCanvas.height=i*e,Object.assign(this._debugCanvas.style,{position:"fixed",left:"0",top:"0",width:`${t}px`,height:`${i}px`,pointerEvents:"none",zIndex:"9999999"}),this._debugContext=this._debugCanvas.getContext("2d")}this._onResizeFunk&&this._onResizeFunk(),this._refreshActiveSets()}triggerAnimations(t=!1){if(t){const t=this._animations.length;for(let i=0;i<t;i++)this._triggerAnimation(this._animations[i])}else for(const t of this._activeAnimations)this._triggerAnimation(t);this._debugContext&&this._drawDebug()}_drawDebug(){if(!this._debugContext||!this._debugCanvas)return;const t=this._debugContext;t.clearRect(0,0,this._debugCanvas.width,this._debugCanvas.height),t.strokeStyle="#f00",t.lineWidth=2*this._pixelRatio,t.beginPath();const i=this._pixelRatio,e=this._viewportHeight;for(const s of this._activeAnimations){const o=s.animationObject,n=o.box.top-o.scroll;n+o.box.height>=0&&n<=e&&t.rect(o.box.left*i,n*i,o.box.width*i,o.box.height*i)}t.stroke()}_triggerAnimation(t,i,e){const s=t.box;if(0===s.height)return;const o=t.animationObject;if(o.scroll=this.scroll,t.smoothing&&t.smoothScroll){const i=60*(e||16.6)/1e3;o.smoothScrollValue=t.smoothScroll(o.scroll,i,t.smoothing)}else o.smoothScrollValue=o.scroll;const n=this._viewportHeight,l=t.directionOffset*(this.isDown?-1:1),a=s.top+s.height-o.smoothScrollValue+l*n+t.offset*n,r=a/(n+s.height),h=(a-n)/s.height,c=t.speed;o.rawFactor=(1-r-.5)*c+.5,o.rawBoxFactor=(1-h-.5)*c+.5,o.factor=o.rawFactor<0?0:o.rawFactor>1?1:o.rawFactor,o.boxFactor=o.rawBoxFactor<0?0:o.rawBoxFactor>1?1:o.rawBoxFactor,o.isInView=i??(o.rawFactor>=0&&o.rawFactor<=1),o.boxIsInView=o.rawBoxFactor>=0&&o.rawBoxFactor<=1,o.box=s,o.fixedTop&&(o.box.top=o.fixedTop),o.isInView!==o.previousIsInView&&(o.isInView?(t.smoothing&&(t.smoothScroll=((t=0)=>(i,e=0,s=.95)=>t=i+(t-i)*s**e)(o.scroll)),o.isScrolledIn=!0,void 0===o.isScrolledInOnce&&(o.isScrolledInOnce=!0)):void 0!==o.previousIsInView&&(o.isScrolledOut=!0,t.smoothScroll=void 0,void 0===o.isScrolledOutOnce&&(o.isScrolledOutOnce=!0))),!t.animation||t.previousFactor===o.factor&&void 0===i||(t.animation(o),t.previousFactor=o.factor),o.isScrolledIn=!1,o.isScrolledOut=!1,o.isScrolledInOnce&&(o.isScrolledInOnce=!1),o.isScrolledOutOnce&&(o.isScrolledOutOnce=!1),o.previousIsInView=o.isInView}add(t,i,e={}){const s=Array.isArray(t)?t:[t],o=!!window.IntersectionObserver,n=void 0===e.observeIn?null:e.observeIn,l=e.directionOffset||0,a=e.offset||0,r=e.speed||1,h=`${l?100*l:1/r*100}% 0% ${l?100*l:a?100*a:1/r*100}% 0%`;let c=null;o&&(c=new window.IntersectionObserver((t=>{for(const i of t){const t=i.target,e=this._animations.find((i=>i.item===t));if(e){const t=i.isIntersecting;e.animationObject.isVisible=t,t&&!e.smoothing?this._activeAnimations.add(e):t||e.smoothing||this._activeAnimations.delete(e),this._triggerAnimation(e,t)}}}),{root:n,rootMargin:h,threshold:0}));const u=window.scrollY||window.pageYOffset;for(let t=0;t<s.length;t++){const o=s[t],n={animation:i,directionOffset:l,offset:a,speed:r,smoothing:e.smoothing,animationObject:{item:o,factor:0,rawFactor:0,rawBoxFactor:0,boxFactor:0,box:{left:0,top:0,width:0,height:0},scroll:0,smoothScrollValue:0,isInView:!1,boxIsInView:!1,index:t,centerOffset:0,originalTop:0,isVisible:!0,data:e.data},item:o,index:t,observer:c,box:{left:0,top:0,width:0,height:0}};this._initBox(n,u),c?(c.observe(o),n.animationObject.isVisible=!1):this._activeAnimations.add(n),n.smoothing&&this._smoothAnimations.add(n),this._animations.push(n)}}_refreshActiveSets(){this._activeAnimations.clear(),this._smoothAnimations.clear();for(const t of this._animations)t.smoothing&&this._smoothAnimations.add(t),t.animationObject.isVisible&&!t.smoothing&&this._activeAnimations.add(t)}remove(t){const i=Array.isArray(t)?t:[t],e=new Set(i),s=[];for(const t of this._animations)e.has(t.item)?(this._triggerAnimation(t,!1),t.observer?.unobserve(t.item),this._activeAnimations.delete(t),this._smoothAnimations.delete(t)):s.push(t);this._animations=s}static getBox(t){const i=t.getBoundingClientRect(),e=window.scrollY||window.pageYOffset,s=window.scrollX||window.pageXOffset;return{left:i.left+s,top:i.top+e,width:i.width,height:i.height}}_initBox(t,i){const e=t.item.getBoundingClientRect(),s=window.scrollX||window.pageXOffset;t.box={left:e.left+s,top:e.top+i,width:e.width,height:e.height},t.animationObject.centerOffset=.5*(this._viewportHeight-t.box.height),t.animationObject.originalTop=t.box.top,t.animationObject.scroll=t.animationObject.smoothScrollValue=this._targetScroll}scrollTo(t=0,i=null){const e=Math.abs(t-this.scroll),s=i??l(25e-5*e,.25,2.5);return this._scrollTween.from({y:this.scroll}).to({y:t},s).start()}scrollToElement(t,i=0,e=null){const s=c.getBox(t);return this.scrollTo(s.top+i,e)}reset(){for(const t of this._animations)t.observer?.unobserve(t.item);this._animations.length=0,this._activeAnimations.clear(),this._smoothAnimations.clear(),this._viewportHeight=0}stop(){this._isAnimating=!1,this._scrollTween.stop()}lock(){this.isLocked=!0}unlock(){this.isLocked=!1,window.scrollTo(0,this.scroll)}setContent(t){this._content=t,this.resize()}unsetContent(){this._content=null}setScrollDuration(t){this._scrollDuration=t}setTouchScrollDuration(t){this._touchScrollDuration=t}destroy(){if(this._debugCanvas?.remove(),this._listener){const t=this._listener,i=h;t.removeEventListener("touchstart",this._touchStartHandler,i),t.removeEventListener("wheel",this._wheelHandler,i),t.removeEventListener("mousedown",this._mouseDownHandler,i),t.removeEventListener("scroll",this._scrollHandler,i)}this.reset(),this.stop(),s.remove(this._tickHandler)}}exports.CubicBezier=i,exports.RenderLoop=s,exports.SmoothScroller=c,exports.Timeline=a,exports.Tween=o,exports.TweenChain=class extends a{constructor(t,i={}){super(i);for(let i=0;i<t.length;i++)this.add(t[i])}}
/**
 * @license
 * Monomove - utilities for moving things
 *
 * Copyright © 2021-2025 Monokai (monokai.com)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the “Software”), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
*/,exports.TweenManager=e,exports.animate=function(t,i,e=1,s="linear"){return new o(t,e).to(i).easing(s).start()},exports.delay=async t=>new o({},t).start(),exports.smoothScroll=function(t,i,e={},s={}){const o=new c(s);return o.add(t,i,e),o},exports.timeline=function(t){return new a(t)};
