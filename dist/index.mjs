var t;class i{#t;#i;#s=0;#e=[0];#n;#o;#l;#a;#r;static#h(t,i,s){return(((1-3*s+3*i)*t+(3*s-6*i))*t+3*i)*t}static#c(t,i,s){return 3*(1-3*s+3*i)*t**2+2*(3*s-6*i)*t+3*i}constructor(t,i=0,s=0,e=0){if(this.#t=16,this.#i=11,this.setCacheSize(this.#i),"string"==typeof t){const i=t.split(",");this.#n=Number(i[0]),this.#o=Number(i[1]),this.#l=Number(i[2]),this.#a=Number(i[3])}else this.#n=t,this.#o=i,this.#l=s,this.#a=e;this.#r=!1}#u(i,s,e,n){let o=s;for(let s=0;s<this.#t;++s){const s=t.#c(o,e,n);if(0===s)return o;o-=(t.#h(o,e,n)-i)/s}return o}#_(){this.#e=new Array(this.#i);for(let i=0;i<this.#i;++i)this.#e[i]=t.#h(i*this.#s,this.#n,this.#l);this.#r=!0}#d(t){const i=this.#i-1;let s=0,e=1;for(;e!==i&&this.#e[e]<=t;++e)s+=this.#s;--e;const n=s+(t-this.#e[e])/(this.#e[e+1]-this.#e[e])*this.#s;return this.#u(t,n,this.#n,this.#l)}get(i){return this.#r||this.#_(),0===i?0:1===i?1:t.#h(this.#d(i),this.#o,this.#a)}setIterations(t){this.#t=t}setCacheSize(t){this.#i=t,this.#s=1/(this.#i-1),this.#e=new Array(this.#i),this.#r=!1}}t=i;class s{static _tweens=[];static _time=0;static _easingCache=new Map;static _isUpdating=!1;static bezierIterations=null;static bezierCacheSize=null;static getAll(){const t=[],i=this._tweens.length;for(let s=0;s<i;s++){const i=this._tweens[s];null!==i&&t.push(i)}return t}static removeAll(){const t=this._tweens.length;for(let i=0;i<t;i++)this._tweens[i]?.stop();this._tweens.length=0,this._easingCache.clear()}static add(t){this._tweens.push(t)}static remove(t){const i=this._tweens.indexOf(t);-1!==i&&(this._isUpdating?this._tweens[i]=null:this._tweens.splice(i,1))}static onlyHasDelayedTweens(t){const i=this._tweens,s=i.length;for(let e=0;e<s;e++){const s=i[e];if(null!==s&&(null===s.startTime||t>=s.startTime))return!1}return s>0}static onTick(t){const i=this._tweens,s=i.length;if(0===s)return!1;this._time=t,this._isUpdating=!0;let e=0;for(let n=0;n<s;n++){const s=i[n];null!==s&&s.update(t)&&(n!==e&&(i[e]=s),e++)}this._isUpdating=!1;const n=i.length;if(n>s)for(let t=s;t<n;t++)i[e++]=i[t];return i.length=e,!0}static setBezierIterations(t){this.bezierIterations=t}static setBezierCacheSize(t){this.bezierCacheSize=t}static getEasingFromCache(t){return this._easingCache.has(t)||this._easingCache.set(t,new i(t)),this._easingCache.get(t)}}class e{static _subscribers=[];static _cleanups=[];static _isUpdating=!1;static _activeCount=0;static _ms=0;static _time=0;static _previousTime=0;static _pauseTime=0;static _pauseTimeStart=0;static _isAnimating=!1;static _requestAnimation=!1;static _requestID=0;static _onlyHasDelayedTweens=!1;static _isFirstTime=!0;static _loopHandler=e._animate.bind(e);static _animate(){const t=window.performance.now();this._time=t-this._pauseTime,this._ms=this._previousTime?this._time-this._previousTime:0;const i=s.onTick(this._time);this._isUpdating=!0;let e=0;const n=this._subscribers.length,o=this._subscribers;for(let t=0;t<n;t++){const i=o[t];null!==i&&!0===i(this._ms)&&e++}if(!this._onlyHasDelayedTweens){const t=this._cleanups;for(let i=0;i<n;i++){const s=t[i];null!==s&&null!==o[i]&&s()}}this._isUpdating=!1,this._activeCount<o.length&&this._compact(),this._onlyHasDelayedTweens=0===e&&s.onlyHasDelayedTweens(this._time),this._previousTime=this._time,this._isAnimating&&(e>0||i)?this._requestID=window.requestAnimationFrame(this._loopHandler):this._requestAnimation=!1}static _compact(){let t=0;const i=this._subscribers.length,s=this._subscribers,e=this._cleanups;for(let n=0;n<i;n++){const i=s[n];null!==i&&(n!==t&&(s[t]=i,e[t]=e[n]),t++)}s.length=t,e.length=t,this._activeCount=t}static stop(t){this._isAnimating=!1,window.cancelAnimationFrame(this._requestID),t&&t()}static add(t,i){this._subscribers.push(t),this._cleanups.push(i||null),this._activeCount++,this.trigger()}static reset(){this._subscribers.length=0,this._cleanups.length=0,this._activeCount=0,s.removeAll()}static remove(t){const i=this._subscribers.indexOf(t);-1!==i&&(this._isUpdating?(this._subscribers[i]=null,this._cleanups[i]=null,this._activeCount--):(this._subscribers.splice(i,1),this._cleanups.splice(i,1),this._activeCount--)),this.trigger()}static trigger(){this._onlyHasDelayedTweens=!1,this._requestAnimation||(this._requestAnimation=!0,this._requestID=window.requestAnimationFrame(this._loopHandler))}static getTime(){return this._time=window.performance.now()-this._pauseTime,this._time}static pause(){this._isAnimating&&(this._pauseTimeStart=window.performance.now(),this._requestAnimation=!1,this.stop())}static play(){this._isAnimating||(this._isFirstTime||(this._pauseTime+=window.performance.now()-this._pauseTimeStart),this._isFirstTime=!1,this.triggerAnimation())}static triggerAnimation(){this._isAnimating=!0,this.trigger()}static isPlaying(){return this._isAnimating}}class n{durationMS;isPlaying;delayTime;startTime;easingFunction;object;value;onTimelineInCallback=null;onTimelineOutCallback=null;onTimelineVisibleCallback=null;onTimelineInvisibleCallback=null;timelineIn=!1;previousTimelineIn=!1;timelineVisible=!1;previousTimelineVisible=!1;_onUpdateCallback;_onLoopCallback;_onCompleteCallback;_onStartCallback;_valuesEnd;_valuesStart;_propKeys;_propStartValues;_propChangeValues;_loopNum;_loopCount;_onStartCallbackFired;_previousTime;_elapsed;_previousUpdateValue;_inverseDuration;_targetIsFunction;constructor(t,i=1){if(this.durationMS=1e3*i,this._inverseDuration=this.durationMS>0?1/this.durationMS:0,this.easingFunction=t=>t,this.value=0,this.delayTime=0,this.isPlaying=!1,this.startTime=null,this._loopNum=0,this._loopCount=0,this._onLoopCallback=null,this._onCompleteCallback=null,this._onStartCallback=null,this._onStartCallbackFired=!1,this._previousTime=null,this._elapsed=0,this._previousUpdateValue=null,this._valuesStart={},this._propKeys=[],this._propStartValues=[],this._propChangeValues=[],"function"==typeof t)this._targetIsFunction=!0,this.object=null,this._onUpdateCallback=t,this._valuesStart.value=0,this._valuesEnd={value:1};else{this._targetIsFunction=!1,this.object=t,this._onUpdateCallback=null,this._valuesEnd={};const i=this.object,s=Object.keys(i);for(let t=0;t<s.length;t++){const e=s[t],n=i[e];"number"==typeof n&&(this._valuesStart[e]=n)}}}from(t){if(this._targetIsFunction){const i=t,s=Object.keys(i);for(const t of s){const s=i[t];"number"==typeof s&&(this._valuesStart[t]=s)}}else for(const i in t){const s=t[i];"number"==typeof s&&this.object&&(this.object[i]=s,this._valuesStart[i]=s)}return this._onUpdateCallback&&this.updateAllValues(0),this}to(t,i){return void 0!==i&&(this.durationMS=1e3*i,this._inverseDuration=this.durationMS>0?1/this.durationMS:0),this._valuesEnd=t,this}duration(t){return this.durationMS=1e3*t,this._inverseDuration=this.durationMS>0?1/this.durationMS:0,this}rewind(){if(!this._targetIsFunction&&this.object){const t=this.object;for(const i in this._valuesStart)t[i]=this._valuesStart[i]}return this.value=this.easingFunction(0),this}restart(){return this.rewind().start()}loop(t=1/0){return this._loopNum=t,this._loopCount=t,this}setLoopCallback(t){return this._onLoopCallback=t,this}startTween(t=e.getTime()){const i=this.isPlaying;if(this._elapsed=0,this._onStartCallbackFired=!1,this.isPlaying=!0,this.startTime=t+this.delayTime,this._propKeys.length=0,this._propStartValues.length=0,this._propChangeValues.length=0,!this._targetIsFunction&&this.object){let t=!1;for(const i in this._valuesEnd){t=!0;break}if(!t){const t=this.object;for(const i in t)if(i in this._valuesStart){const s=t[i];"number"==typeof s&&(this._valuesEnd[i]=s)}}}for(const t in this._valuesEnd){const i=this._valuesEnd[t];let s=this._valuesStart[t];if(!this._targetIsFunction&&void 0===s&&this.object){const i=this.object[t];"number"==typeof i&&(s=i,this._valuesStart[t]=s)}this._targetIsFunction&&void 0===s&&(s=0),"number"==typeof s&&"number"==typeof i&&(this._propKeys.push(t),this._propStartValues.push(s),this._propChangeValues.push(i-s))}return 0===this.durationMS&&0===this._loopNum&&0===this.delayTime?(this.update(t),this.isPlaying=!1):i||(s.add(this),e.triggerAnimation()),this}start(t){const i=this._onCompleteCallback;return new Promise((s=>{this._onCompleteCallback=(t,e)=>{i&&i(t,e),this._onCompleteCallback=i,s(this)},this.startTween(t)}))}stop(){return this.isPlaying?(this.isPlaying=!1,s.remove(this),this):this}delay(t){return this.delayTime=1e3*t,this}easing(t=(t=>t),{iterations:i=s.bezierIterations??void 0,cacheSize:e=s.bezierCacheSize??void 0}={}){if(!t)return this;if("string"==typeof t){const n=s.getEasingFromCache(t);i&&n.setIterations&&n.setIterations(i),e&&n.setCacheSize&&n.setCacheSize(e),this.easingFunction=n.get.bind(n)}else if("object"==typeof t&&null!==t&&"get"in t){const s=t;i&&s.setIterations&&s.setIterations(i),e&&s.setCacheSize&&s.setCacheSize(e),this.easingFunction=s.get.bind(s)}else this.easingFunction=t;return this}onStart(t){return this._onStartCallback=t,this}onUpdate(t){return this._onUpdateCallback=t,this}onComplete(t=null){return this._onCompleteCallback=t,this}onTimelineIn(t){return this.onTimelineInCallback=t,this}onTimelineOut(t){return this.onTimelineOutCallback=t,this}onTimelineVisible(t){return this.onTimelineVisibleCallback=t,this}onTimelineInvisible(t){return this.onTimelineInvisibleCallback=t,this}setPosition(t){const i=t<0?0:t>1?1:t;this.value=this.easingFunction(i),this.updateAllValues()}updateAllValues(t=0){if(this.value!==this._previousUpdateValue){if(this._targetIsFunction){if(this._propStartValues.length>0){const i=this._propStartValues[0]+this._propChangeValues[0]*this.value;this._onUpdateCallback&&this._onUpdateCallback(i,this.value,t)}}else{const i=this._propKeys.length,s=this._propKeys,e=this._propStartValues,n=this._propChangeValues,o=this.value,l=this.object;for(let t=0;t<i;t++)l[s[t]]=e[t]+n[t]*o;this._onUpdateCallback&&this._onUpdateCallback(this.object,o,t)}this._previousUpdateValue=this.value}}invalidate(){return this._previousUpdateValue=null,this}update(t){if(null===this.startTime)return!0;if(t<this.startTime)return!0;!1===this._onStartCallbackFired&&(null!==this._onStartCallback&&this.object&&this._onStartCallback(this.object),this._onStartCallbackFired=!0,e.trigger()),this._elapsed=t-this.startTime;const i=0===this.durationMS?1:this._elapsed*this._inverseDuration,s=i>1?1:i;this.value=this.easingFunction(s),null===this._previousTime&&(this._previousTime=t);const n=t-this._previousTime;if(this._previousTime=t,this.updateAllValues(n),1===s){const s=this.startTime;this._loopCount>0?(this._onLoopCallback&&this.object&&this._onLoopCallback(this.object,this._loopNum-this._loopCount),this._loopCount--,this.restart()):this._onCompleteCallback&&this.isPlaying&&this.object&&this._onCompleteCallback(this.object,t-this.startTime);const e=s!==this.startTime;return this.isPlaying=e||this.isPlaying&&i<1,this.isPlaying}return!0}}class o{previousPosition;startTime=null;delayTime=0;durationMS=0;value=0;easingFunction=t=>t;_driverTween=null;_tweens=[];_loopNum=0;totalTime=0;constructor({delay:t=0}={}){this.previousPosition=0,this.delayTime=1e3*t}static setTweenIn(t,i){t.timelineIn=i,t.timelineIn!==t.previousTimelineIn&&(i&&t.onTimelineInCallback&&t.object?t.onTimelineInCallback(t.object):!i&&t.onTimelineOutCallback&&t.object&&t.onTimelineOutCallback(t.object),t.previousTimelineIn=t.timelineIn)}static setTweenVisibility(t,i){t.timelineVisible=i,t.timelineVisible!==t.previousTimelineVisible&&(i&&t.onTimelineVisibleCallback&&t.object?t.onTimelineVisibleCallback(t.object):!i&&t.onTimelineInvisibleCallback&&t.object&&t.onTimelineInvisibleCallback(t.object),t.previousTimelineVisible=t.timelineVisible)}delay(t){return this.delayTime=1e3*t,this}loop(t=1/0){return this._loopNum=t,this}stop(){return this._driverTween?.stop(),this}destroy(){this.stop();for(let t=0;t<this._tweens.length;t++)this._tweens[t].stop();this._tweens.length=0,this.totalTime=0}start(){const t=new n((t=>{this.setPosition(t)}),this.totalTime/1e3);return this._driverTween=t,0!==this._loopNum&&t.loop(this._loopNum),t.delay(this.delayTime/1e3),t.start().then((()=>this))}updateAllValues(){}invalidate(){}}function l(t,i,s=Number.MAX_VALUE){return t<i?i:t>s?s:t}class a extends o{_startTimes=[];_durations=[];_cursor=0;constructor(t){super(t)}add(t,i=0){const s=void 0!==t.totalTime?t.totalTime:t.durationMS,e=1e3*i,n=this._cursor+e;return this._register(t,n,s),this}at(t,i){const s=void 0!==i.totalTime?i.totalTime:i.durationMS,e=1e3*t;return this._register(i,e,s),this}_register(t,i,s){t.delayTime=i,this._tweens.push(t),this._startTimes.push(i),this._durations.push(s);const e=i+s;e>this._cursor&&(this._cursor=e),e>this.totalTime&&(this.totalTime=e)}setPosition(t){const i=l(t,0,1)*this.totalTime,s=this._tweens.length,e=this._startTimes,a=this._durations,r=this._tweens;for(let t=0;t<s;t++){const s=r[t],l=e[t],h=a[t],c=l+h;if(i<l)s.setPosition(0),s instanceof n&&(o.setTweenVisibility(s,!1),o.setTweenIn(s,!1),s.invalidate(),s.updateAllValues());else if(i>=c)s.setPosition(1),s instanceof n&&(o.setTweenVisibility(s,!0),o.setTweenIn(s,!1),s.invalidate(),s.updateAllValues());else{const t=0===h?1:(i-l)/h;s.setPosition(t),s instanceof n&&(o.setTweenVisibility(s,!0),o.setTweenIn(s,!0),s.invalidate(),s.updateAllValues())}}this.previousPosition=t}update(t){return this.setPosition(this.previousPosition||0),!0}}let r=!1;try{const t=Object.defineProperty({},"passive",{get:()=>(r=!0,!0)});window.addEventListener("test",(()=>{}),t),window.removeEventListener("test",(()=>{}),t)}catch(t){}const h=!!r&&{passive:!0};class c{isDown=!1;isLocked=!1;scroll=0;scrollWidth=0;scrollHeight=0;_pixelRatio=1;_scrollThreshold=.01;_targetScroll=0;_previousScroll=0;_viewportHeight=0;_animations=[];_activeAnimations=new Set;_smoothAnimations=new Set;_debugCanvas=null;_debugContext=null;_isAnimating=!1;_previousScrollWidth=0;_previousScrollHeight=0;_isFirstScrollInstant=!0;_isTouch=!1;_scrollTween=new n({y:0}).easing("0.35,0.15,0,1").onUpdate((t=>{window.scrollTo(0,t.y),this._isAnimating=!0,this.scroll=t.y,this._targetScroll=t.y,this.isDown=this._targetScroll>=this._previousScroll,this._previousScroll=this._targetScroll}));_touchScrollDuration=0;_scrollDuration=0;_container;_content;_listener;_debug=!1;_onResizeFunk=null;_totalTickTime=0;_scrollFrom=0;_easing;_getScrollFn;_tickHandler=this._onTick.bind(this);_touchStartHandler=()=>{this.isLocked||(this._isTouch=!0)};_mouseDownHandler=t=>{t.stopPropagation(),this.isLocked||(this._isTouch=!1)};_wheelHandler=()=>{this.isLocked||(this._scrollTween.stop(),this._isTouch=!1)};_scrollHandler=()=>{if(this.isLocked)return;this._isAnimating=!0;const t=Math.max(0,this.scrollHeight-this._viewportHeight),i=this._getScrollFn();this._targetScroll=i<0?0:i>t?t:i,this._scrollFrom=this.scroll,this._totalTickTime=0};constructor({container:t=window.document.body,content:i=window.document.body,easing:s=(t=>Math.min(1,1.001-2**(-10*t))),scrollFactor:n=null,scrollDuration:o=0,listener:l=window,debug:a=!1,onResize:r}={}){if(this._scrollDuration=o||0,this._container=t,this._content=i,this._listener=l,this._debug=a||!1,this._easing=s,this._onResizeFunk=r||null,"scrollY"in this._listener)this._getScrollFn=()=>this._listener.scrollY;else if("pageYOffset"in this._listener)this._getScrollFn=()=>this._listener.pageYOffset;else{const t=this._listener;this._getScrollFn=()=>t.scrollTop}this._setupListeners(),this._setupDebug(),e.add(this._tickHandler),e.play(),this.resize()}_setupListeners(){if(!this._listener)return;const t=h,i=this._listener;i.addEventListener("touchstart",this._touchStartHandler,t),i.addEventListener("scroll",this._scrollHandler,t),i.addEventListener("mousedown",this._mouseDownHandler,t),i.addEventListener("wheel",this._wheelHandler,t)}_setupDebug(){this._debug&&this._container&&(this._debugCanvas=document.createElement("canvas"),this._container.appendChild(this._debugCanvas))}_onTick(t){if(this.isLocked)return!0;const i=this._content.scrollWidth,s=this._content.scrollHeight;if(i!==this.scrollWidth||s!==this.scrollHeight)return this.scrollWidth=i,this.scrollHeight=s,this._previousScrollWidth=i,this._previousScrollHeight=s,this.resize(),this.scroll=this._scrollFrom=this._targetScroll,this._updateAll(this.scroll),!0;if(this._smoothAnimations.size>0)for(const i of this._smoothAnimations)Math.abs(i.animationObject.smoothScrollValue-this.scroll)>this._scrollThreshold&&this._triggerAnimation(i,void 0,t);if(!this._isAnimating)return!0;const e=this._targetScroll-this.scroll;if(Math.abs(e)<this._scrollThreshold)return Math.abs(e)>0&&(this.scroll=this._targetScroll,this._updateAll(this.scroll)),this._isTouch&&this.triggerAnimations(!0),this._isAnimating=!1,!0;this._totalTickTime+=t/1e3;const n=this._isTouch?this._touchScrollDuration:this._scrollDuration,o=0===n?1:l(this._totalTickTime/n,0,1),a=this._easing(o);if(this.scroll=this._scrollFrom+(this._targetScroll-this._scrollFrom)*a,this._isFirstScrollInstant){this._isFirstScrollInstant=!1,this.scroll=this._scrollFrom=this._targetScroll;const t=this.isDown;this.isDown=!0,this.triggerAnimations(!0),this.isDown=!1,this.triggerAnimations(!0),this.isDown=t}return this._updateAll(this.scroll),!0}_updateAll(t){if(this.isDown=t>=this._previousScroll,this._previousScroll=t,this._activeAnimations.size>0)for(const t of this._activeAnimations)this._triggerAnimation(t);this._debugContext&&this._drawDebug()}draw(){this._updateAll(this.scroll)}drawAll(){for(const t of this._animations)this._triggerAnimation(t)}getScrollPosition(){return this._getScrollFn()}resize(){if(!this._container||!this._content)return;this.scroll=this._scrollFrom=this._previousScroll=this._targetScroll,this.scrollHeight=this._content.scrollHeight,this._viewportHeight=window.innerHeight,this._pixelRatio=window.devicePixelRatio;const t=window.scrollY||window.pageYOffset;for(let i=0;i<this._animations.length;i++)this._initBox(this._animations[i],t);if(this._debugCanvas){const t=window.innerWidth,i=window.innerHeight,s=this._pixelRatio;this._debugCanvas.width=t*s,this._debugCanvas.height=i*s,Object.assign(this._debugCanvas.style,{position:"fixed",left:"0",top:"0",width:`${t}px`,height:`${i}px`,pointerEvents:"none",zIndex:"9999999"}),this._debugContext=this._debugCanvas.getContext("2d")}this._onResizeFunk&&this._onResizeFunk(),this._refreshActiveSets()}triggerAnimations(t=!1){if(t){const t=this._animations.length;for(let i=0;i<t;i++)this._triggerAnimation(this._animations[i])}else for(const t of this._activeAnimations)this._triggerAnimation(t);this._debugContext&&this._drawDebug()}_drawDebug(){if(!this._debugContext||!this._debugCanvas)return;const t=this._debugContext;t.clearRect(0,0,this._debugCanvas.width,this._debugCanvas.height),t.strokeStyle="#f00",t.lineWidth=2*this._pixelRatio,t.beginPath();const i=this._pixelRatio,s=this._viewportHeight;for(const e of this._activeAnimations){const n=e.animationObject,o=n.box.top-n.scroll;o+n.box.height>=0&&o<=s&&t.rect(n.box.left*i,o*i,n.box.width*i,n.box.height*i)}t.stroke()}_triggerAnimation(t,i,s){const e=t.box;if(0===e.height)return;const n=t.animationObject;if(n.scroll=this.scroll,t.smoothing&&t.smoothScroll){const i=60*(s||16.6)/1e3;n.smoothScrollValue=t.smoothScroll(n.scroll,i,t.smoothing)}else n.smoothScrollValue=n.scroll;const o=this._viewportHeight,l=t.directionOffset*(this.isDown?-1:1),a=e.top+e.height-n.smoothScrollValue+l*o+t.offset*o,r=a/(o+e.height),h=(a-o)/e.height,c=t.speed;n.rawFactor=(1-r-.5)*c+.5,n.rawBoxFactor=(1-h-.5)*c+.5,n.factor=n.rawFactor<0?0:n.rawFactor>1?1:n.rawFactor,n.boxFactor=n.rawBoxFactor<0?0:n.rawBoxFactor>1?1:n.rawBoxFactor,n.isInView=i??(n.rawFactor>=0&&n.rawFactor<=1),n.boxIsInView=n.rawBoxFactor>=0&&n.rawBoxFactor<=1,n.box=e,n.fixedTop&&(n.box.top=n.fixedTop),n.isInView!==n.previousIsInView&&(n.isInView?(t.smoothing&&(t.smoothScroll=((t=0)=>(i,s=0,e=.95)=>t=i+(t-i)*e**s)(n.scroll)),n.isScrolledIn=!0,void 0===n.isScrolledInOnce&&(n.isScrolledInOnce=!0)):void 0!==n.previousIsInView&&(n.isScrolledOut=!0,t.smoothScroll=void 0,void 0===n.isScrolledOutOnce&&(n.isScrolledOutOnce=!0))),!t.animation||t.previousFactor===n.factor&&void 0===i||(t.animation(n),t.previousFactor=n.factor),n.isScrolledIn=!1,n.isScrolledOut=!1,n.isScrolledInOnce&&(n.isScrolledInOnce=!1),n.isScrolledOutOnce&&(n.isScrolledOutOnce=!1),n.previousIsInView=n.isInView}add(t,i,s={}){const e=Array.isArray(t)?t:[t],n=!!window.IntersectionObserver,o=void 0===s.observeIn?null:s.observeIn,l=s.directionOffset||0,a=s.offset||0,r=s.speed||1,h=`${l?100*l:1/r*100}% 0% ${l?100*l:a?100*a:1/r*100}% 0%`;let c=null;n&&(c=new window.IntersectionObserver((t=>{for(const i of t){const t=i.target,s=this._animations.find((i=>i.item===t));if(s){const t=i.isIntersecting;s.animationObject.isVisible=t,t&&!s.smoothing?this._activeAnimations.add(s):t||s.smoothing||this._activeAnimations.delete(s),this._triggerAnimation(s,t)}}}),{root:o,rootMargin:h,threshold:0}));const u=window.scrollY||window.pageYOffset;for(let t=0;t<e.length;t++){const n=e[t],o={animation:i,directionOffset:l,offset:a,speed:r,smoothing:s.smoothing,animationObject:{item:n,factor:0,rawFactor:0,rawBoxFactor:0,boxFactor:0,box:{left:0,top:0,width:0,height:0},scroll:0,smoothScrollValue:0,isInView:!1,boxIsInView:!1,index:t,centerOffset:0,originalTop:0,isVisible:!0,data:s.data},item:n,index:t,observer:c,box:{left:0,top:0,width:0,height:0}};this._initBox(o,u),c?(c.observe(n),o.animationObject.isVisible=!1):this._activeAnimations.add(o),o.smoothing&&this._smoothAnimations.add(o),this._animations.push(o)}}_refreshActiveSets(){this._activeAnimations.clear(),this._smoothAnimations.clear();for(const t of this._animations)t.smoothing&&this._smoothAnimations.add(t),t.animationObject.isVisible&&!t.smoothing&&this._activeAnimations.add(t)}remove(t){const i=Array.isArray(t)?t:[t],s=new Set(i),e=[];for(const t of this._animations)s.has(t.item)?(this._triggerAnimation(t,!1),t.observer?.unobserve(t.item),this._activeAnimations.delete(t),this._smoothAnimations.delete(t)):e.push(t);this._animations=e}static getBox(t){const i=t.getBoundingClientRect(),s=window.scrollY||window.pageYOffset,e=window.scrollX||window.pageXOffset;return{left:i.left+e,top:i.top+s,width:i.width,height:i.height}}_initBox(t,i){const s=t.item.getBoundingClientRect(),e=window.scrollX||window.pageXOffset;t.box={left:s.left+e,top:s.top+i,width:s.width,height:s.height},t.animationObject.centerOffset=.5*(this._viewportHeight-t.box.height),t.animationObject.originalTop=t.box.top,t.animationObject.scroll=t.animationObject.smoothScrollValue=this._targetScroll}scrollTo(t=0,i=null){const s=Math.abs(t-this.scroll),e=i??l(25e-5*s,.25,2.5);return this._scrollTween.from({y:this.scroll}).to({y:t},e).start()}scrollToElement(t,i=0,s=null){const e=c.getBox(t);return this.scrollTo(e.top+i,s)}reset(){for(const t of this._animations)t.observer?.unobserve(t.item);this._animations.length=0,this._activeAnimations.clear(),this._smoothAnimations.clear(),this._viewportHeight=0}stop(){this._isAnimating=!1,this._scrollTween.stop()}lock(){this.isLocked=!0}unlock(){this.isLocked=!1,window.scrollTo(0,this.scroll)}setContent(t){this._content=t,this.resize()}unsetContent(){this._content=null}setScrollDuration(t){this._scrollDuration=t}setTouchScrollDuration(t){this._touchScrollDuration=t}destroy(){if(this._debugCanvas?.remove(),this._listener){const t=this._listener,i=h;t.removeEventListener("touchstart",this._touchStartHandler,i),t.removeEventListener("wheel",this._wheelHandler,i),t.removeEventListener("mousedown",this._mouseDownHandler,i),t.removeEventListener("scroll",this._scrollHandler,i)}this.reset(),this.stop(),e.remove(this._tickHandler)}}class u extends a{constructor(t,i={}){super(i);for(let i=0;i<t.length;i++)this.add(t[i])}}
/**
 * @license
 * Monomove - utilities for moving things
 *
 * Copyright © 2021-2025 Monokai (monokai.com)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the “Software”), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
*/function _(t,i,s=1,e="linear"){return new n(t,s).to(i).easing(e).start()}function d(t){return new a(t)}const m=async t=>new n({},t).start();function p(t,i,s={},e={}){const n=new c(e);return n.add(t,i,s),n}export{i as CubicBezier,e as RenderLoop,c as SmoothScroller,a as Timeline,n as Tween,u as TweenChain,s as TweenManager,_ as animate,m as delay,p as smoothScroll,d as timeline};
